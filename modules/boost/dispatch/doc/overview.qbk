[chapter Overview
    [quickbook 1.5]
]

[section Objectives]
This library aims at providing an idiomatic way to define functions that can
be extended or specialized, with each specialization being able to be generic
and the most efficient possible with respect to architecture and compiler
specificities. This is achieved through:

* Macros and meta-functions abstracting and completing the various ABI specific
  issues related to the efficient passing of arguments to functions.

* Transparent tag dispatching system with which it becomes possible to select
  the best specialization for the arguments provided, avoiding the limitations
  inherent to unconstrained template function overloads.

* Extensible generic functor abstraction wrapping the tag dispatching machinery
  and providing a simple to use protocol to extend arbitrary functions.

[warning Boost.Dispatch is a library in development and is not part of Boost.]

[endsect]

[section Introduction to Tag Dispatching]
Let us consider a fairly artificial scenario, but representative of things that
are quite common in generic programming: we want to define a unary function `f`,
for all built-in arithmetic types, that implements different algorithms depending
on the actual type of the argument. For example, consider that `f` returns 0 if
its argument is a floating point value, returns 1 if it is a signed integer or
return 2 otherwise.

[section Implementation using SFINAE]
You could do this using *SFINAE*. SFINAE - standing for Substitution Failure Is
Not An Error - is a C++ idiom relying on the way the compiler prune invalid
function definitions from an overload set instead of emitting errors. This pruning,
when done on purpose, can be used to select a function implementation based on
arbitrary compile-time checks on function argument types.

The traditional way to implement SFINAE enabled functions is to use the
`enable_if` meta-function helper. This is done in the following way:

[c++]
``
template<class T>
typename enable_if<is_floating_point<T>,int>::type
f(T)
{
  return 0;
}

template<class T>
typename enable_if<mpl::and_< is_signed<T>,is_integral<T> >,int>::type
f(T)
{
  return 1;
}

template<class T>
typename enable_if<mpl::and_< mpl::not_< is_signed<T> >,is_integral<T> >,int>::type
f(T)
{
  return 2;
}
``
The SFINAE approach has some well-known issues:

* The number of instantiated template functions is linear with the number of
  cases.
* Conditions must be strictly disjoint or ambiguity may arise.
* Code intent is blurred by the syntactic burden of `enable_if`.

[endsect]

[section Implementation using Tag Dispatching]

Another solution, which is heralded by the Standard Template Library itself
is to use a technique known as Tag Dispatching. Tag dispatching relies on using
a hierarchy of types describing the relationship between kind of types and
their properties. Any type can be externally bound to a given tag, and so, bound
to a given implementation of any function recognizing this tag.:

[c++]
``
struct unknown_tag                              {};
struct fundamental_tag                          {};
struct floating_point_tag     : fundamental_tag {};
struct integral_tag           : fundamental_tag {};
struct signed_integral_tag    : integral_tag    {};
struct unsigned_integral_tag  : integral_tag    {};

template<class T> struct category_of                { typedef unknown_tag type;           };
template<>        struct category_of<float>         { typedef floating_point_tag type;    };
template<>        struct category_of<double>        { typedef floating_point_tag type;    };
template<>        struct category_of<int>           { typedef signed_integral_tag type;   };
template<>        struct category_of<unsigned int>  { typedef unsigned_integral_tag type; };

/* etc. for all other fundamental types... */

template<class T> int f(T t)
{
  return f(t, typename category_of<T>::type() );
}

template<class T> int f(T, floating_point_tag const&)
{
  return 0;
}

template<class T> int f(T, integral_tag const&)
{
  return 1;
}

template<class T> int f(T, unsigned_integral_tag const&)
{
  return 2;
}
``

By using a hierarchy of types bound by inheritance, it's possible to make use
of the best-match feature of C++ overloading to introduce specializations
without requiring them to be mutually exclusive. The `iterator_category`
system of standard iterators is a good example of that.

Doing this in a clean, concise, reusable and idiomatic manner is however of some
difficulty, which is why that is only done in an ad-hoc way in practice.
[endsect]
[endsect]

[section Boost.Dispatch in action]
Boost.Dispatch solves these problems through two related components:

* An extensible hierarchy system that contains ready-made hierarchies and that
can be easily extended. This provides a powerful and idiomatic way to define
inheriting category tags embedding arbitrary level of intentionality.

* A dispatching mechanism built on top of the hierarchies and overloading,
that automates the use of tag dispatching with one or all arguments.

Here is what the free function example looks like when written with Boost.Dispatch:

[c++]
``
#include <boost/dispatch/meta/hierarchy_of.hpp>
using namespace boost::dispatch;

template<class T> int f(T t)
{
  return f(t, typename meta::hierarchy_of<T>::type() );
}

template<class T> int f(T, scalar_< floating_<T> > const&)
{
  return 0;
}

template<class T> int f(T, scalar_< integer_<T> > const&)
{
  return 1;
}

template<class T> int f(T, scalar_< unsigned_<T> > const&)
{
  return 2;
}
``

Notice how the second specialization applies to any integral type, including
unsigned ones. However, since there is also a specialization for unsigned types,
the latter gets preferred, since `unsigned_` is a refinement of `integer_`
in the built-in hierarchies.

[endsect]

[xinclude reference.xml]
